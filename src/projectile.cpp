#include "entity.hpp"
#include <iostream>

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//		KONSTRUKTOR
projectile::projectile()
{
	this->EfctsCausedByBlt = NULL;
	this->animCounter = this->actualOrigRadiusSize = this->origRadiusSize = this->colorCounter = 0;
	this->PartOfDrawnCircle = 1.;
	this->step = 1;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void projectile::create(sf::Vector2f playerPos, double angle, rangeWeapon *weapon)
{
	// po 2.5 sekundach ka¿dy pocisk zostaje usuniêty ¿eby nie obci¹¿aæ zbytnio procka
	timeOfProjection.restart();
	maxTimeOfProjection = 2.5f;
	this->EfctsCausedByBlt = &weapon->EffectWeaponCauses;

	// metoda która w zale¿noœci od broni odpowiednio wyreguluje prêdkoœæ, kierunek, itp.
	this->manageEffectsInit(*weapon, angle);

	// ustawienie kó³eczka 
	this->setFillColor(sf::Color::Red);
	this->setRadius(weapon->bulletSize);
	this->setPosition(playerPos);
	this->setOrigin(this->getRadius(), this->getRadius());

	this->origRadiusSize = this->getRadius();
	this->actualOrigRadiusSize = this->getRadius() * this->PartOfDrawnCircle;
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void projectile::update()
{
	//assert(this->EfctsCausedByBlt == NULL);
	switch (this->EfctsCausedByBlt->type)
	{
	case typeOfWeapon::ENERGETIC:
	{
		this->handleEnergeticAnimations();
		break;
	}
	case typeOfWeapon::PLASMA:
	{
		this->handlePlasmaAnimations();
		break;
	}

	}
	// po prostu update
	this->move(this->Vx, this->Vy);
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
double projectile::getRandomVal(int minVal, int maxVal)
{
	double val = (rand() % ((maxVal - minVal) + 1)) + minVal;
	return val;
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
Verticle projectile::getCenter()
{
	return Verticle{ this->getPosition().x, this->getPosition().y };
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
effects projectile::getEffects()
{
	return *this->EfctsCausedByBlt;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
double projectile::getDmg()
{
	return this->damage;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
sf::Time projectile::getTime()
{
	return this->timeOfProjection.getElapsedTime();
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
double projectile::getMaxTime()
{
	return this->maxTimeOfProjection;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void projectile::manageEffectsInit(rangeWeapon weapon, double angle)
{
	this->recoilValue = rand() % static_cast<int>(weapon.recoil) + 1;
	this->Vx = std::abs(this->getRandomVal(weapon.minSpeedOfBullet, weapon.maxSpeedOfBullet));
	this->Vy = std::abs(this->getRandomVal(weapon.minSpeedOfBullet, weapon.maxSpeedOfBullet));
	this->damage = getRandomVal(weapon.minDamage, weapon.maxDamage);


	// metoda która zajmuje siê ogarniêciem efektów z prefixem a_... (czyli te dla wszystkich a.k.a. celowniki itp.)
	handleCommonEffects(weapon);

	// w zale¿noœci od tego jaki typ kulki to jest to odpowiednio to modyfikujemy
	switch (this->EfctsCausedByBlt->type)
	{
	case typeOfWeapon::PLASMA:
		this->managePlasmaEffectsinit();
		break;
	case typeOfWeapon::BULLETTYPE:
		this->manageBulletTypeEffectsInit();
		break;
	case typeOfWeapon::ENERGETIC:
		this->manageEnergeticEffectsInit();
		break;
	}

	// ustawiamy kierunek lotu 		
	this->Vx *= cos(angle);
	this->Vy *= sin(angle);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void projectile::managePlasmaEffectsinit()
{
	this->PartOfDrawnCircle = 1. / static_cast<double>((rand() % 3 + 1));

	this->Vx *= g_plasmaSpeedBuff;
	this->Vy *= g_plasmaSpeedBuff;
	this->damage *= (1.0 / g_plasmaSpeedBuff);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void projectile::manageEnergeticEffectsInit()
{
	this->PartOfDrawnCircle = 1. / static_cast<double>((rand() % 2+ 1));
	this->Vx *= g_energeticSpeedBuff;
	this->Vy *= g_energeticSpeedBuff;
	this->damage *= (1.0 / g_energeticSpeedBuff);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void projectile::manageBulletTypeEffectsInit()
{

}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void projectile::handleCommonEffects(rangeWeapon weapon)
{
	if (EfctsCausedByBlt->a_hasStabilization)
	{
		recoilValue /= 2;
	}
}
void projectile::handleEnergeticAnimations()
{
	// wprowadzamy chaos do broni energetycznej
	this->animCounter += static_cast<double>((rand() % 10 + 25)) / static_cast<double>(FPS);
	
	//		wykres funkcji :  y = 2 * |cos(x)| * sin(x)^2 
	this->setRadius(this->origRadiusSize * (1.0 - PartOfDrawnCircle) +	2* std::abs(cos(animCounter))* sin(animCounter) * sin(animCounter) * PartOfDrawnCircle*this->origRadiusSize);


	this->colorCounter = (this->colorCounter + rand() % 25 + 10) % 255;
	this->setFillColor(sf::Color(this->getFillColor().r, this->getFillColor().g, this->colorCounter));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void projectile::handlePlasmaAnimations()
{
	// broñ plazmowa mniej chaotyczna ni¿ broñ energetyczna 
	this->animCounter += static_cast<double>((rand() % 5 + 1)) / static_cast<double>(FPS);

	//					wykres rozmiaru pocisku : y = |sin(x)| * cos(x)^4 * 3
	this->setRadius(this->origRadiusSize + std::abs(sin(animCounter)*cos(animCounter)*std::pow(sin(animCounter),4)*3*this->origRadiusSize*PartOfDrawnCircle));

	
	this->colorCounter = (this->colorCounter + rand() % 25) % 255;
	this->setFillColor(sf::Color(this->getFillColor().r, this->colorCounter, this->getFillColor().b));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////